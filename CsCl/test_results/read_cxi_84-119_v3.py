#*************************************************************************
# Import CXI-files from simulations with Condor (v1.0) and plot data
# cxi-files located in the same folder, result saved  in subfolder ""<name_run_pdb_(noise-sprd_noise)_#N>""
# File format is optiona, indexing start with '0' 
# Currently tetsting with data from simulation of CsCl
#   plots saved to choosen file-format 'frmt'
#   Intensity Pattern = abs(Amplitude_Pattern)^2) are plotted directly as
#           '..._data-nabs_...' without taking the modulus in the plot
#            and as a log10 plot '..._log10_...' and are in reciprocal space
#  Projection patterns '..._rs_...' in real space are from inv Fourier transform of data
#              (and FFT-shifted)
#   Patterson_Image '..._patterson_image_...' are from FFTshift-Fast Fourier transforms-FFTshift
#           of Intensity Patterns =  AutoCorrelated image (can be used as initial guess for phae retrieval)
#
# 2019-01-21 v3 calculate F-Transforms here (not in write file) @ Caroline Dahlqvist cldah@kth.se
#			compatable with test_CsCl_84-119_v5- generated cxi-files
#	simulation parameters are loaded from CSI-file:
#		pixel size [um], number of pixles (X,Y), photon energy [eV] photon wavelength[m]
# Prometheus path: /Users/Lucia/Documents/KTH/Ex-job_Docs/Simulations_CsCl/test_results/
# lynch path: /Users/lynch/Documents/users/caroline/Simulations_CsCl/test_results/
#*************************************************************************
# not tested! need cxi -file generated by test_...v5 !
import h5py 
import numpy as np
from numpy.fft import fftn, fftshift # no need to use numpy.fft.fftn/fftshift
import matplotlib.pyplot as pypl
from matplotlib import ticker	#for changing # ticks in colorbar
# %pylab	# code as in Matlab
import os
this_dir = os.path.dirname(os.path.realpath(__file__)) # Get path of directory

# ----	Parameters unique to file: ----
frmt = "eps"
name = "test_mask"
run = "84-119"
pdb= "4M0_ed"      # 92 structure-files for each concentration. 
#rt = 1		# Ratio of particles (if 1: only CsCl loaded, if != 1: mxture with Water-particle)
N = 5#3#1		# Number of iterations performed = Number of Diffraction Patterns Simulated
#ps = 110	# [um] pixel width
#pxls = 1738 	# number of Pixels
noisy = "none"
n_spread = 0

# ---- Make an Output Dir: ----
outdir = this_dir +'/%s_%s_%s_(%s-sprd%s)_#%i/' %(name,run,pdb,noisy,n_spread,N)
if not os.path.exists(outdir):
    os.makedirs(outdir)


# ----	Read in Data from CXI-file: ----
#with h5py.File(this_dir +'/%s_84-119_%s_(r%iof10-ps%ium-ny%i-%s-sprd%s)_#%i.cxi'%(name,pdb,rt*10,ps,pxls,noisy,n_spread,N), 'r') as f:
with h5py.File(this_dir +'/%s_%s_%s_(%s-sprd%s)_#%i.cxi'%(name,run,pdb,noisy,n_spread,N), 'r') as f:
		intensity_pattern = np.asarray(f["entry_1/data_1/data"])
		amplitudes_pattern = np.asarray(f["entry_1/data_1/data_fourier"])
		mask = np.asarray(f["entry_1/data_1/mask"])		# Mask + Data ???
		#patterson_image = np.asarray(f["patterson_image"]) # fftshift(fftn(fftshift(intensity_pattern)))
		#projection_image = np.asarray(f["projection_image"]) #fftshift(fftn(fftshift(amplitudes_pattern)))
		#real_space = np.asarray(f["real_space"]) #nump.fft.fftshift(numpy.fft.ifftn(res["entry_1"]["data_1"]["data_fourier"])) #not saved in 'test_1AON_84-119_v2'
		
		photon_e_eV = np.asarray(f["source/incident_energy"] )			# [eV]
		photon_e_eV = int(photon_e_eV[0]) 								# typecast 'Dataset' to int

		photon_wavelength = np.asarray(f["source/incident_wavelength"]) #[m]
		photon_wavelength= float(photon_wavelength[0])					# typecast 'Dataset' to float

		psa = np.asarray(f["detector/pixel_size_um"])  					#[um]
		ps = int(psa[0]) 												# typecast 'Dataset' to int

		dtc_dist_arr = np.asarray(f["detector/detector_dist_m"])			#[m]
		dtc_dist = float(dtc_dist_arr[0]) 									# typecast 'Dataset' to float


#print "pixel size data-type: ", type(ps), " value: ", ps, " and nparray: ", psa
#print "pixel size data-type: ", type(ps), " value: ", dtc_dist, " and nparray: ", dtc_dist_arr

print "Number of Patterns Reorded: ", len(intensity_pattern) # lenght of list = # Patterns
print "Dimensions of Mask[0]: ", mask[0].shape # size of list 
print "Dimensions of Mask: ", mask.shape # size of list 
#print "Dimensiton of 1st Pattern: ", intensity_pattern[0].shape  # size of forst Patterns

# ----- From "Reading CXI files -- Condor":
#print("Maximum intensity value in first pattern: %f photons" % intensity_pattern[0].max())
#print("Maximum intensity value in second pattern: %f photons" % intensity_pattern[1].max())
for i in range(len(intensity_pattern)):
	print("Maximum intensity value in pattern number %i : %f photons" % (i,intensity_pattern[i].max()) )


#	--- Mask from assembly: ---
mask_better = np.load("%s/../masks/better_mask-assembled.npy" %str(this_dir))
mask_better = mask_better.astype(int)		# Force to int() and not float()
print "Dimensions of Better-Mask-Assembled: ", mask_better.shape # size of list 


# ------------------- Calculate the FFT: -------------------
# fftshift: Shift the zero-frequency component to the center of the spectrum
# np.fft.ifftn Compute the N-dimensional inverse discrete Fourier Transform
patterson_image =np.fft.fftshift(np.fft.fftn(np.fft.fftshift(intensity_pattern)))
projection_image =fftshift(fftn(fftshift(amplitudes_pattern)))
Projection_image_w_Mask = fftshift(fftn(fftshift(amplitudes_pattern*mask)))
Projection_image_w_MaskAssembled = fftshift(fftn(fftshift(amplitudes_pattern*mask_better)))


# ------------------- Calculate the Absolute value & Add Masks for the Plots: -------------------
I_p_abs = np.abs(intensity_pattern) 	# all Patterns in Array; 1st <name>[0], 2st <name>[1]s
Pr_i_abs =np.abs(projection_image)      # Porjection Image (real-space) in Arrays
Pat_im_abs =np.abs(patterson_image)     # Patterson Images in Arrays = AutoCorrelation (can be used as suspected guess for phase retrieval)
ProIm_Mask = np.abs(Projection_image_w_Mask)	# FFT of AMpl*MASK(CXI)
ProIm_MaskAssmbld =np.abs(Projection_image_w_MaskAssembled) 	# FFT of AMpl*MASK(Assembled)

mask_tr = np.matrix.transpose(mask[0])	# Transpose of Mask from CXI-file, dim:(1742, 1738)
#print "Dimensions of Mask_Transpose: ", mask_tr.shape # size (1742, 1738)
#I_p_w_mask_mtrx = np.matmul(I_p_abs[0], mask_tr)	#(1738, 1738) Matrix Multiplication
I_p_w_mask_arr0=np.multiply(I_p_abs[0],mask[0]) #(1738, 1742) Mask from CXI: a = np.array([[1,2],[3,4]]), b = np.array([[5,6],[7,8]]), np.multiply(a,b)
I_p_w_mask_arr = np.multiply(I_p_abs,mask) 		# Mask from CXI(Condor)
(pxls_x, pxls_y )= mask[0].shape
#print "Dimensions of matrix multiplication mtrx - arr: ", I_p_w_mask_mtrx.shape,'-' , I_p_w_mask_arr.shape # size 
#I_p_w_mb=np.multiply(I_p_abs,mask_better)		#Intensity Pattern*better-mask-assembled
I_p_w_mb=np.abs(np.multiply(intensity_pattern,mask_better))		#Intensity Pattern*better-mask-assembled
I_p_wmb_Amp_sq = np.abs(np.abs(amplitudes_pattern*mask_better)**2) #abs(Amplitudes*better-mask-assembled)^2


# ---- Select which Plots tp view in Run: ----
plt_I0, plt_I0_zoom, plt_I0_log = True, False, False
plt_Ip_sub, plt_Ip_sub_log10, plt_Ip_Pr_sub = False, False, False#True # Subplots :

#	--	change text format in titles/labels: --
#pypl.rcParams.update({'axes.titlesize': 'small', 'axes.labelsize': 16, 'xtick.labelsize':'x-large', 'ytick.labelsize':'x-large'})
# weight or fontweight	[ 'normal' | 'bold' | 'heavy' | 'light' | 'ultrabold' | 'ultralight']
# style or fontstyle	[ 'normal' | 'italic' | 'oblique' ]
####################################################################################
#------------------------------------ PLOTS: ------------------------------------
####################################################################################
# --- Show Intensity Pattern of 1st Pattern (Full Image): ----
if plt_I0:
#pypl.imshow(I_p.reshape(201,201), interpolation='nearest', vmax=500000)
	fig_int0_1 = pypl.figure()
	px_x= pxls_x/2	# Half the pixel size for x center 0
	px_y= pxls_y/2	# Half the pixel size for y center 0
	
	#pypl.imshow(I_p_abs[0], extent=[-px_x,px_x,-px_y,px_y])	# Intensity Pattern 1st
	#pic_name = 'Intensity_I_p_abs[0].%s'%(frmt)

	#pypl.imshow(mask[0],extent=[-px_x,px_x,-px_y,px_y])	# Mask Intensity [0,500] ??, # Mask from CXI-file (entry_1/data_1/mask)
	#pic_name = 'Mask-CXI_mask[0].%s'%(frmt)

	#pypl.imshow(I_p_w_mask_arr[0])#, extent=[-px_x,px_x,-px_y,px_y]) # 1st, ## ERR! Same as I_p_abs (intensity Pattern)
	#pic_name = 'Intensity_I_p_w_mask_arr[0].%s'%(frmt)

	#pypl.imshow(ProIm_Mask[0],extent=[-px_x,px_x,-px_y,px_y])	#1st Projection Im after add CXI/Mask
	#pic_name = 'Projection_ProIm_Mask[0].%s'%(frmt)


	#pypl.imshow(I_p_w_mb[0],extent=[-px_x,px_x,-px_y,px_y], vmin=0, vmax=I_p_w_mb[0].max())#, extent=[-px_x,px_x,-px_y,px_y]) # Mask_better .* 1stIntensity Pattern
	#pic_name = 'Intensity_I_p_w_mb[0].%s'%(frmt)
	pypl.imshow(I_p_wmb_Amp_sq[0], extent=[-px_x,px_x,-px_y,px_y], vmin=0, vmax=I_p_w_mb[0].max())#, extent=[-px_x,px_x,-px_y,px_y]) # Mask_better .* 1stIntensity Pattern
	pic_name = 'Intensity_I_p_wmb_Amp_sq[0].%s'%(frmt)

	#pypl.imshow(ProIm_MaskAssmbld[0])#,extent=[-px_x,px_x,-px_y,px_y]) 	#1st Projection Im after add exp-file/Mask
	#pic_name = 'Projection_ProIm_MaskAssmbld[0].%s'%(frmt)


	pypl.ylabel('Pixels', fontsize=14)
	pypl.xlabel('Pixels', fontsize=14)
	#pypl.title("Intensity Pattern") 
	pypl.title(pic_name, fontsize=16)
	cb = pypl.colorbar()
	cb.set_label('Intensity', fontsize=14)
	pypl.show()	# works ok
	#fig_int0_1.savefig(outdir + pic_name)
 	#pypl.savefig(outdir + pic_name)
 	
 	#print "Plot saved in %s \n as %s" %(outdir, pic_name)


# --- Show Intensity Pattern of 1st Pattern (Zoom Image): ----
if plt_I0_zoom:
	fig_int0_2 = pypl.figure()
	#pypl.imshow(I_p_abs[0])
	#px2= pxls/2	# Half the pixel size for center 0
	px_x= pxls_x/2	# Half the pixel size for x center 0
	px_y= pxls_y/2	# Half the pixel size for y center 0
	pypl.imshow(I_p_abs[0], extent=[-px2,px2,-px2,px2]) # extent=[-px_x,px_x,-px_y,px_y]
	zx, zy = 50, 50
	pypl.ylim([-zx,zx])
	pypl.xlim([-zy,zy])
	pypl.ylabel('y [Pixels]')
	pypl.xlabel('x [Pixels]')
	pypl.title("Intensity Pattern (Zoomed)")
	cb = pypl.colorbar()
	cb.set_label('Intensity')
	pypl.show()	# works ok

# --- Show Intensity Pattern of 1st Pattern (Log10 Image): ----
if plt_I0_log:
	fig_int0_log = pypl.figure()
	#pypl.imshow(I_p_abs[0])
	pypl.imshow(np.log10(I_p_abs[0]))	# log-10 of 1st intensity pattern
	#pypl.imshow(np.log10(I_p_w_mb0))	# With Mask
	pypl.ylabel('Pixels')
	pypl.xlabel('Pixels')
	pypl.title("Intensity Pattern (log10)")
	cb = pypl.colorbar()
	cb.set_label(r'Intensity log$_{10}$')
	pypl.show()	# works ok
	
	#fig_int0_log.savefig(this_dir +'/%s_%s_%s_(%s-sprd%s)_#%i/1st_Intensity-Pattern_log10.%s' %(name,run,pdb,noisy,n_spread,N,frmt))
	#fig_int0_log.savefig(this_dir +'/%s_%s_%s_(%s-sprd%s)_#%i/1st_Intensity-Pattern_times_Mask-from-file_log10.%s' %(name,run,pdb,noisy,n_spread,N,frmt))



# #########################################################################
# ------------------------------ SUBPLOTS: ------------------------------
# #########################################################################
# --- Subplot with Show N=3 Intensity Pattern : ----
if plt_Ip_sub:
	#px2= pxls/2	# Half the pixel size for center 0
	px2= pxls_x/2	# Half the pixel size for center 0
	zx, zy = 50, 50
	#pypl.subplots_adjust(hspace=0.5, left=0.07, right=0.95)
	pypl.subplots_adjust(wspace=0.5, left=0.07, right=0.95)
	for i in range(N):		#Projection Images (I_p_abs)
		pypl.subplot(1,N,i+1) # unneccessary if fig_sp, axs = pypl.subplots(ncols = 3, ...)
		ax = pypl.gca()
		im1 = ax.imshow(I_p_abs[i], extent=[-px2,px2,-px2,px2])
		ax.set_xlim([-zx, zx])	# Zoom at centre
		ax.set_ylim([-zy, zy])	# Zoom acentret 
		ax.set_ylabel('y Pixles', fontsize=14)
		ax.set_xlabel('x Pixles', fontsize=14)
		ax.set_title("Intensity Pattern", fontsize=14)
		cb = pypl.colorbar(im1, orientation="horizontal", shrink=0.9, pad= 0.2)	# work but wrong scale
		cb.set_label(r'Intensity ')
	pypl.show()


# --- Subplot with Show N=3 log10(Intensity Pattern ): ----  (Loop, independen of N value)
if plt_Ip_sub_log10 :
	#px2= pxls/2	# Half the pixel size for center 0
	px_x= pxls_x/2	# Half the pixel size for x center 0
	px_y= pxls_y/2	# Half the pixel size for y center 0
	#pypl.subplot(131) # unneccessary if ig_sp, axs = pypl.subplots(ncols = 3, ...)
	#ax = pypl.gca()
	#im1 = ax.imshow(np.log10(I_p0), extent=[-px2,px2,-px2,px2])
	# ---- For plotting in log10 without np.log10 calculation first, by using LogNorm & LogLocator (colorbar with 10^x): ----
	#from matplotlib.colors import LogNorm
	#from matplotlib.ticker import LogLocator
	# -------------------------------------------------------------------------------------------------------------------------
	fig_sp, axs = pypl.subplots(nrows =1, ncols = N, sharey=True, squeeze=False, figsize=(15,4)) # (1,3), sharex = True,sharey=True
	# , squeeze=False: Error occurs when len(channels) equals 1.  if False then indexing ax[i]->[0,i] for 1 row
	#	You can suppress this behavior by setting squeeze=False in the .subplots() command. This forces it to always return a 'Rows x Cols' sized array with the axes.		
	# ---- adjust spacing between subplots so  title and  tick labels don't overlap --------
	#fig_sp.subplots_adjust(hspace=0.5, left=0.07, right=0.93)
	fig_sp.subplots_adjust(hspace=0.1, wspace=0.5, left=0.07, right=0.95, bottom=0.1, top=0.95)
	#fig_sp.subplots_adjust(hspace=0.2, wspace=0.2, left=0.07, right=0.95, bottom=0.5, top=0.95)
	#fig_sp.subplots_adjust(hspace=0.2, wspace=0.2, left=0.5, right=0.5, bottom=0.1, top=0.95) # Err:left cannot be >= right 
	#fig_sp.subplots_adjust(wspace=0.5, hspace=0.2,  left=0.07, right=0.95)#, bottom=0.1, top=0.95) 
	cb_shrink = 0.5		# Shrinkage of ColorBar; alter length of colorbar prop to image
	cb_padd = 0.1		# Padding of ColorBar; prevent overlap with axes
	fig_sp.suptitle('Intensity Pattern with log10 scale', fontsize=14)
	#pypl.rcParams.update({'axes.labelsize': 16, 'xtick.labelsize':'small', 'ytick.labelsize':'small'})
	if N ==1:
		for i in range(N):	
			im = pypl.imshow(np.log10(I_p_abs[i]), extent=[-px_x,px_x,-px_y,px_y])	 # if N=1
			#im = pypl.imshow(np.log10(I_p_w_mb[i]), extent=[-px_x,px_x,-px_y,px_y])#	if N=1 With MASK
			pypl.xlabel('x Pixles')												 # if N=1
			cb = fig_sp.colorbar(im,shrink=cb_shrink, pad= cb_padd, label=r'$\log_{10}\ $')  # if N=1
		pypl.ylabel('y Pixels') # if N=1
	else: 
		for i in range(N):
		#for ax in axs:	#used with ax.imshow, squeezed = True ...
			ax = axs[0,i] # if squeeze is True or not set: axs[i]
			im=ax.imshow(np.log10(I_p_abs[i]), extent=[-px_x,px_x,-px_y,px_y]) 
			#im=ax.imshow(np.log10(I_p_w_mb[i]), extent=[-px_x,px_x,-px_y,px_y]) #with MASK
			ax.set_xlabel('x Pixles') # for N =1: AttributeError: 'numpy.ndarray' object has no attribute 'set_xlabel'
			cb = fig_sp.colorbar(im, ax=ax, shrink=cb_shrink, pad= cb_padd)#, label=r'$\log_{10}\ $')
			cb.set_label(label=r'$\log_{10}\ $', weight='bold', size=12)
			#im=axs[0,i].imshow(np.log10(I_p_abs[i]), extent=[-px2,px2,-px2,px2]) # for N =1: TypeError: 'AxesSubplot' object does not support indexing
			#im = axs[0,i].imshow(np.log10(I_p_w_mb[i]), extent=[-px2,px2,-px2,px2])	 #  With MASK
			#axs[i].set_xlabel('x Pixles') # for N =1: AttributeError: 'numpy.ndarray' object has no attribute 'set_xlabel'
			#cb = fig_sp.colorbar(im, ax=axs[i],shrink=cb_shrink, pad= cb_padd, label=r'$\log_{10}\ $')

			# ---- For plotting in log10 without np.log10 calculation first, by using LogNorm & LogLocator (colorbar with 10^x): ----
			#im = axs[i].imshow(I_p_abs[i], extent=[-px2,px2,-px2,px2], norm=LogNorm()) # extent or  aspect ='equal'
			#cb = fig_sp.colorbar(im, ax=axs[i], ticks=LogLocator(), shrink=cb_shrink, pad= cb_padd, label=r'$\log_{10}\ $')  # ticks=None, should yield small ticks (NOTWOKRING)
			#cb.update_ticks()
			# -------------------------------------------------------------------------------------------------------------------------
		axs[0,0].set_ylabel('y Pixles') # if N=1: AttributeError: 'numpy.ndarray' object has no attribute 'set_ylabel'
		pypl.rcParams.update({'axes.labelsize': 16, 'xtick.labelsize':'small', 'ytick.labelsize':'small'})
	fig_sp.tight_layout()
	pypl.show()
	# ---- Save Fig to File (without or with MASK): ----
	pic_name = 'subplots_Intensity_log10'
	#fig_sp.savefig(outdir +'%s.%s' %(pic_name,frmt))
	#print "Plot saved in %s \n as %s.%s" %(outdir, pic_name, frmt)
	pic_nameM = 'subplots_Intensity_log10_w_Mask' 	#with MASK
	#fig_sp.savefig(outdir +'%s.%s' %(pic_nameM,frmt)) 	#with MASK
	#print "Plot saved in %s \n as %s.%s" %(outdir, pic_nameM, frmt) 	#with MASK
	

# --- Subplot with Show N=3 Intensity Pattern & Projected Image: ----
if plt_Ip_Pr_sub:
	#############  REAL-SPACE PXL CONVERSION (Rescaling Projection axis) : #############
	#import condor
	#photon = condor.utils.photon.Photon(energy_eV =9500)
	#wl = photon.get_wavelength()
	from math import *

	lmd = photon_wavelength # wl # [m] wavelength
	#d = 0.15		#[m] Detector Distance
	#pxls = 1516	# number of Pixels
	#ps = 110E-6	#[m] Pixel Size
	#h_f_pxls = float(pxls*ps*1E-6) # [m] detector hight from # of Pixels [um]
	h_f_pxls = float(pxls_x*ps*1E-6) # [m] detector hight from # of Pixels [um]
	h_f_area = 18.5E-2    #[m] Detector Area 18.5x18.5 cm

	# ---- Half-Scattering Angle: ----
	theta_pxls = atan2(h_f_pxls, 2*dtc_dist)
	theta_area = atan2(h_f_area, 2*dtc_dist)

	Q_max_pxls = [(4*pi/lmd)*sin(theta_pxls/2), (4*pi/lmd)*sin(theta_pxls)]   # Q-value : transferred momentum vector
	Q_max_area = [(4*pi/lmd)*sin(theta_area/2), (4*pi/lmd)*sin(theta_area)]  # Q-value : transferred momentum vector

	Q_max_pxls = np.array(Q_max_pxls, 'f')
	Q_max_area = np.array(Q_max_area, 'f')

	#for i in range(D_Q_area.shape[1]):
	#	D_Q_pxls= Q_max_pxls[i]-0 # Q_max - q_min 	# Total range {usually Q_min =0}
	#	D_Q_area= Q_max_area[i]-0 # Q_max - q_min     # Total range {usually Q_min =0}
	D_Q_pxls= Q_max_pxls # Q_max - Q_min 	# Total range {usually Q_min =0}
	D_Q_area= Q_max_area # Q_max - Q_min     # Total range {usually Q_min =0}
	# d_Q = (2*pi)/D_r 	# Q-resolution (pixel distance in Fourier Space)
	d_r_pxls =(2*pi)/D_Q_pxls		# [m] r - resolution (pixel distance in real space)
	d_r_area =(2*pi)/D_Q_area        # [m] r - resolution (pixel distance in real space)
	d_r = [[d_r_pxls], [d_r_area]]	# dr from  Row1:pixels, Row2: area
	#print "from #pixels: ", d_r_pxls, " \n from detector area: ", d_r_area
	#print "from #pixels: [pixels[old, new]],[area[old, new]] ", d_r
	#D_r = ...	# Rotal Field of View r_max-r_min
	####################################################################################
	rs_m = d_r_area[1] #float(ps/5) 	#need float; estimeted form unit sphere of 1 nm diametre ~5 pxls compare with Condor_publication fig.5: 1AON (GroEL-GroES): ~20 nm
	#		try new calc where theta = 1/2 scattering angle <= estimated from arctan of right-triangle
	rs_nm = rs_m*1E+9	# [nm] convert from [m] to [nm] by 10^+9
	rs = rs_nm	#set which unit to present in
	#print "convert: ", rs 	# 

	#px2= pxls/2	# Half the pixel size for center 0
	#px2= pxls_x/2	# Half the pixel size for center 0
	px_x= pxls_x/2	# Half the pixel size for x center 0
	px_y= pxls_y/2	# Half the pixel size for y center 0
	zpxls  = 50 	# (Intensity Pattern) Zoom to pxl dist in x and y direcction, from centre
	z_rs 	= float(zpxls)/5.0	 # (Projection Image) Zoom to pxl dist in x and y direcction, from centre
	#print "Length of projection_image: ", len(projection_image[0]) 
	#print "Shape of projection_image: ",  projection_image[0].shape
	cb_shrink = 1.0 #0.6 (for N=1) #0.7 #0.8		# Shrinkage of ColorBar; alter length of colorbar prop to image
	cb_padd = 0.2#0.3 #0.2		# Padding of ColorBar; prevent overlap with axes
	#fig_sp = pypl.figure() # fig_sp.add_subplot(2,N,i+1)
	pypl.rcParams["figure.figsize"] = (15,7)
	#pypl.rcParams.update({'axes.labelsize': 16, 'xtick.labelsize':'x-large', 'ytick.labelsize':'x-large'})
	for i in range(N):		#1st Row: Projection Images (I_p_abs)
		pypl.subplot(2,N,i+1)  # unneccessary if fig_sp, axs = pypl.subplots(ncols = 3, ...)
		ax = pypl.gca()
		im1 = ax.imshow(I_p_abs[i], extent=[-px_x,px_x,-px_y,px_y]) #extent = scaling
		# im1 = ax.imshow(I_p_w_mb[i] , extent=[-px2,px2,-px2,px2])  # Masked miltiplied
		ax.set_xlim([-zpxls, zpxls])	# Zoom at centre
		ax.set_ylim([-zpxls, zpxls])	# Zoom acentret 
		#im1 = ax.imshow(I_p_abs[i][px2-zpxls:px2+zpxls, px2-zpxls:px2+zpxls])#, extent=[-px2,px2,-px2,px2]) #extent = scaling
		if i ==0: ax.set_ylabel('y Pixles')
		ax.set_xlabel('x Pixles')
		ax.set_title("Intensity (zoomed in)")
		cb = pypl.colorbar(im1, orientation="horizontal", shrink=cb_shrink, pad= cb_padd)	# work but wrong scale
		cb.set_label(r'Intensity ')
		cb.locator = ticker.MaxNLocator(nbins=5) # from matplotlib import ticker
		cb.update_ticks()
	for i in range(N):	#2nd Row: Projection Images (Pr_i_abs)
		pypl.subplot(2,N, N+i+1) # unneccessary if fig_sp, axs = pypl.subplots(ncols = 3, ...)
		ax = pypl.gca()
		im1 = ax.imshow(Pr_i_abs[i], extent=[-px2*rs,px2*rs,-px2*rs,px2*rs])#, try new (half-ang)
		ax.set_xlim([-z_rs, z_rs])	# Zoom at centre
		ax.set_ylim([-z_rs, z_rs])	# Zoom acentret
		if i == 0: ax.set_ylabel('y [nm]')	# if rs_m : [m], if rs_nm: [nm]
		ax.set_xlabel(r'x [nm]')#[$\mu$m]') # if rs_m : [m], if rs_nm: [nm]
		ax.set_title("Projection (zoomed in)")
		cb = pypl.colorbar(im1, orientation="horizontal", shrink=cb_shrink, pad= cb_padd)	# work but wrong scale
		cb.set_label(r'Electron Densitu [a.u.]')
		cb.locator = ticker.MaxNLocator(nbins=5) # from matplotlib import ticker
		cb.update_ticks()
	#pypl.subplots_adjust(wspace=0.2, hspace=0.5, left=0.07, right=0.95)
	#pypl.subplots_adjust(wspace=0.2, hspace=0.5, left=0.07, right=0.99)
	pypl.subplots_adjust(wspace=0.1, hspace=0.2, left=0.07, right=0.99)
	pypl.rcParams.update({'axes.labelsize': 16, 'xtick.labelsize':'small', 'ytick.labelsize':'small'})
	pypl.tight_layout() 
	pypl.show()
	#### Need figure -handle, show plot and then save after closing: ###
	#fig_sp.savefig(this_dir +'/%s_%s_%s_(%s-sprd%s)_#%i/Intensity(zoomd)_projection(zoomed).%s' %(name,run,pdb,noisy,n_spread,N,frmt))
	#fig_sp.close()
	#pypl.close()

	##### Remove 'pypl.show()' and save direcly: ####
 	#pypl.savefig(this_dir +'/%s_%s_%s_(%s-sprd%s)_#%i/Intensity(zoomd)_projection(zoomed).%s' %(name,run,pdb,noisy,n_spread,N,frmt))
 	#pic_name = 'Intensity(zoomd)_projection(zoomed).%s'%(frmt)
 	#pypl.savefig(outdir + pic_name)
 	#print "Plot saved in %s \n as %s" %(outdir, pic_name)



# --- Plot data in one row of Pixels of 1st Pattern : ----
#	from matplotlib.pyplot import figure,draw	#use functions draw() & figure()
#	fig1 = figure()	# if load %pylab or from matplotlib import figure, draw
#fig_int0_plt = pypl.figure()	# Intensity Profile 
#ax = fig_int0_plt.gca()
#ax.plot(I_p0[:,0], lw=2) # 1st diff pattern or I_p_abs[0,:,0] e.g. (ip[:,0], ip[:,1], lw=2)
#ax.set_ylabel('Intensity')
#pypl.xlabel('Pixels') #	e.g. pypl.xlabel(r'$q \ \ [\AA^{-1}]$')
#pypl.show()	# or if previous plt: pypl.draw()

